<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plain HTML Style Guide</title>
    <style>
        /* Intentionally boring CSS */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: Times New Roman, serif;
            font-size: 16px;
            line-height: 1.5;
            color: #000;
            background: #fff;
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
        }

        h1 { font-size: 24px; margin-bottom: 10px; font-weight: normal; }
        h2 { font-size: 18px; margin: 30px 0 10px; font-weight: normal; }
        p { margin-bottom: 10px; }
        hr { border: none; border-top: 1px solid #000; margin: 30px 0; }

        .section { margin-bottom: 40px; }

        /* Boring button */
        .btn {
            font-family: Times New Roman, serif;
            font-size: 16px;
            padding: 8px 16px;
            background: #fff;
            border: 1px solid #000;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        /* Boring input */
        .input {
            font-family: Times New Roman, serif;
            font-size: 16px;
            padding: 8px;
            border: 1px solid #000;
            width: 100%;
            max-width: 300px;
            margin-bottom: 10px;
            display: block;
        }

        /* Boring card */
        .card {
            border: 1px solid #000;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-title { font-weight: bold; margin-bottom: 10px; }

        /* Badge */
        .badge {
            display: inline-block;
            border: 1px solid #000;
            padding: 2px 8px;
            font-size: 12px;
            margin-right: 5px;
        }

        /* Color swatches */
        .swatch {
            display: inline-block;
            width: 60px;
            height: 60px;
            border: 1px solid #000;
            margin-right: 10px;
            margin-bottom: 10px;
            vertical-align: top;
        }

        /* Three.js canvas */
        #chaos-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* Interactive elements get a class */
        .chaos-target {
            position: relative;
            z-index: 1;
        }

        /* Hidden message */
        .secret {
            font-size: 10px;
            color: #ccc;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <canvas id="chaos-canvas"></canvas>

    <h1 class="chaos-target" data-effect="explode">Plain HTML Style Guide</h1>
    <p>A simple, no-nonsense design system. Nothing fancy here.</p>

    <hr>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Colors</h2>
        <p>We use two colors: black and white.</p>
        <div class="swatch chaos-target" data-effect="vortex" style="background: #fff;"></div>
        <div class="swatch chaos-target" data-effect="vortex" style="background: #000;"></div>
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Typography</h2>
        <p>Times New Roman. The default. Why change what works?</p>
        <p style="font-size: 24px;" class="chaos-target" data-effect="glitch">Aa Bb Cc Dd Ee</p>
        <p style="font-size: 18px;">The quick brown fox jumps over the lazy dog.</p>
        <p style="font-size: 14px;">Small text for less important things.</p>
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Buttons</h2>
        <p>Standard buttons. They click.</p>
        <button class="btn chaos-target" data-effect="explode">Button</button>
        <button class="btn chaos-target" data-effect="explode">Another Button</button>
        <button class="btn chaos-target" data-effect="explode">Submit</button>
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Form Elements</h2>
        <p>Basic inputs for basic needs.</p>
        <input type="text" class="input chaos-target" data-effect="ripple" placeholder="Text input">
        <input type="text" class="input chaos-target" data-effect="ripple" placeholder="Another input">
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Cards</h2>
        <p>Boxes for content.</p>
        <div class="card chaos-target" data-effect="wobble">
            <div class="card-title">Card Title</div>
            <p>This is a card. It contains information. The border is 1 pixel.</p>
        </div>
        <div class="card chaos-target" data-effect="wobble">
            <div class="card-title">Another Card</div>
            <p>Cards can hold any content. This one has text.</p>
            <button class="btn">Action</button>
        </div>
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Badges</h2>
        <span class="badge chaos-target" data-effect="spin">Default</span>
        <span class="badge chaos-target" data-effect="spin">Active</span>
        <span class="badge chaos-target" data-effect="spin">New</span>
    </div>

    <div class="section">
        <h2 class="chaos-target" data-effect="wave">Spacing</h2>
        <p>We use sensible spacing: 10px, 20px, 30px, 40px.</p>
        <div style="display: flex; align-items: flex-end; gap: 10px; margin-top: 10px;">
            <div class="chaos-target" data-effect="bounce" style="width: 20px; height: 20px; background: #000;"></div>
            <div class="chaos-target" data-effect="bounce" style="width: 20px; height: 40px; background: #000;"></div>
            <div class="chaos-target" data-effect="bounce" style="width: 20px; height: 60px; background: #000;"></div>
            <div class="chaos-target" data-effect="bounce" style="width: 20px; height: 80px; background: #000;"></div>
        </div>
    </div>

    <hr>

    <p>That's the whole system. Simple, functional, boring.</p>

    <p class="secret">hover over things...</p>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ═══════════════════════════════════════════════════════════════
        // THE CHAOS ENGINE
        // ═══════════════════════════════════════════════════════════════

        const canvas = document.getElementById('chaos-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Particle system for explosions
        const particleCount = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = [];
        const particleColors = new Float32Array(particleCount * 3);
        const particleLifetimes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = 0;
            particlePositions[i * 3 + 1] = 0;
            particlePositions[i * 3 + 2] = -100; // Hidden
            particleVelocities.push({ x: 0, y: 0, z: 0 });
            particleColors[i * 3] = 0;
            particleColors[i * 3 + 1] = 0;
            particleColors[i * 3 + 2] = 0;
            particleLifetimes[i] = 0;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Geometric shapes pool
        const shapes = [];
        const shapeGeometries = [
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.TetrahedronGeometry(0.2),
            new THREE.OctahedronGeometry(0.15),
            new THREE.TorusGeometry(0.1, 0.05, 8, 16),
            new THREE.IcosahedronGeometry(0.15)
        ];

        const shapeMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            wireframe: true
        });

        for (let i = 0; i < 50; i++) {
            const geo = shapeGeometries[Math.floor(Math.random() * shapeGeometries.length)];
            const mesh = new THREE.Mesh(geo, shapeMaterial.clone());
            mesh.position.z = -100;
            mesh.userData = { active: false, velocity: { x: 0, y: 0, z: 0 }, spin: { x: 0, y: 0, z: 0 }, life: 0 };
            shapes.push(mesh);
            scene.add(mesh);
        }

        // Lines for wave effects
        const waveLines = [];
        for (let i = 0; i < 20; i++) {
            const points = [];
            for (let j = 0; j < 50; j++) {
                points.push(new THREE.Vector3(j * 0.1 - 2.5, 0, 0));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            const line = new THREE.Line(geometry, material);
            line.position.z = -100;
            line.userData = { active: false, offset: i * 0.2, amplitude: 0 };
            waveLines.push(line);
            scene.add(line);
        }

        // Vortex rings
        const vortexRings = [];
        for (let i = 0; i < 10; i++) {
            const geometry = new THREE.TorusGeometry(0.5 + i * 0.1, 0.02, 8, 64);
            const material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.z = -100;
            ring.userData = { active: false, targetScale: 0, spin: 0 };
            vortexRings.push(ring);
            scene.add(ring);
        }

        // Screen shake
        let shakeIntensity = 0;
        let shakeDecay = 0.95;

        // Convert screen coords to 3D
        function screenTo3D(x, y) {
            const vec = new THREE.Vector3(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1,
                0.5
            );
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            return camera.position.clone().add(dir.multiplyScalar(distance));
        }

        // Get element center in 3D
        function getElementCenter(el) {
            const rect = el.getBoundingClientRect();
            return screenTo3D(rect.left + rect.width / 2, rect.top + rect.height / 2);
        }

        // ═══════════════════════════════════════════════════════════════
        // EFFECTS
        // ═══════════════════════════════════════════════════════════════

        let particleIndex = 0;

        function triggerExplode(el) {
            const center = getElementCenter(el);
            shakeIntensity = 0.1;

            // Spawn particles
            for (let i = 0; i < 80; i++) {
                const idx = (particleIndex + i) % particleCount;
                const positions = particleGeometry.attributes.position.array;
                const colors = particleGeometry.attributes.color.array;

                positions[idx * 3] = center.x;
                positions[idx * 3 + 1] = center.y;
                positions[idx * 3 + 2] = 0;

                const angle = Math.random() * Math.PI * 2;
                const speed = 0.05 + Math.random() * 0.15;
                const elevation = (Math.random() - 0.5) * 0.1;

                particleVelocities[idx] = {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed + 0.02,
                    z: elevation
                };

                colors[idx * 3] = 0;
                colors[idx * 3 + 1] = 0;
                colors[idx * 3 + 2] = 0;

                particleLifetimes[idx] = 1;
            }
            particleIndex = (particleIndex + 80) % particleCount;
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;

            // Spawn shapes
            for (let i = 0; i < 8; i++) {
                const shape = shapes.find(s => !s.userData.active);
                if (shape) {
                    shape.position.copy(center);
                    shape.position.z = Math.random() * 0.5;
                    shape.userData.active = true;
                    shape.userData.life = 1;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.03 + Math.random() * 0.05;
                    shape.userData.velocity = {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed + 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    };
                    shape.userData.spin = {
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    };
                    shape.material.opacity = 1;
                    shape.scale.setScalar(0.5 + Math.random() * 0.5);
                }
            }
        }

        function triggerWave(el) {
            const center = getElementCenter(el);

            waveLines.forEach((line, i) => {
                line.position.x = center.x;
                line.position.y = center.y + (i - 10) * 0.05;
                line.position.z = 0;
                line.userData.active = true;
                line.userData.amplitude = 0.3;
                line.material.opacity = 0.8;
            });
        }

        function triggerVortex(el) {
            const center = getElementCenter(el);
            shakeIntensity = 0.05;

            vortexRings.forEach((ring, i) => {
                ring.position.copy(center);
                ring.position.z = 0;
                ring.userData.active = true;
                ring.userData.targetScale = 1 + i * 0.3;
                ring.userData.spin = 0.1 + i * 0.02;
                ring.scale.setScalar(0.1);
                ring.material.opacity = 0.8;
            });
        }

        function triggerGlitch(el) {
            const center = getElementCenter(el);
            shakeIntensity = 0.15;

            // Rapid particle bursts
            for (let burst = 0; burst < 3; burst++) {
                setTimeout(() => {
                    for (let i = 0; i < 30; i++) {
                        const idx = (particleIndex + i) % particleCount;
                        const positions = particleGeometry.attributes.position.array;

                        positions[idx * 3] = center.x + (Math.random() - 0.5) * 2;
                        positions[idx * 3 + 1] = center.y + (Math.random() - 0.5) * 0.5;
                        positions[idx * 3 + 2] = 0;

                        particleVelocities[idx] = {
                            x: (Math.random() - 0.5) * 0.1,
                            y: (Math.random() - 0.5) * 0.1,
                            z: 0
                        };
                        particleLifetimes[idx] = 0.5;
                    }
                    particleIndex = (particleIndex + 30) % particleCount;
                    particleGeometry.attributes.position.needsUpdate = true;
                }, burst * 50);
            }
        }

        function triggerRipple(el) {
            const center = getElementCenter(el);

            vortexRings.slice(0, 5).forEach((ring, i) => {
                setTimeout(() => {
                    ring.position.copy(center);
                    ring.position.z = 0;
                    ring.userData.active = true;
                    ring.userData.targetScale = 2;
                    ring.userData.spin = 0;
                    ring.scale.setScalar(0.1);
                    ring.material.opacity = 0.6;
                }, i * 100);
            });
        }

        function triggerWobble(el) {
            const center = getElementCenter(el);

            for (let i = 0; i < 5; i++) {
                const shape = shapes.find(s => !s.userData.active);
                if (shape) {
                    const angle = (i / 5) * Math.PI * 2;
                    shape.position.x = center.x + Math.cos(angle) * 0.5;
                    shape.position.y = center.y + Math.sin(angle) * 0.3;
                    shape.position.z = 0;
                    shape.userData.active = true;
                    shape.userData.life = 1;
                    shape.userData.velocity = { x: 0, y: 0, z: 0 };
                    shape.userData.spin = {
                        x: (Math.random() - 0.5) * 0.3,
                        y: (Math.random() - 0.5) * 0.3,
                        z: 0.1
                    };
                    shape.userData.orbit = { center, angle, radius: 0.5, speed: 0.05 };
                    shape.material.opacity = 1;
                    shape.scale.setScalar(0.3);
                }
            }
        }

        function triggerSpin(el) {
            const center = getElementCenter(el);

            const shape = shapes.find(s => !s.userData.active);
            if (shape) {
                shape.position.copy(center);
                shape.position.z = 0;
                shape.userData.active = true;
                shape.userData.life = 2;
                shape.userData.velocity = { x: 0, y: 0.02, z: 0 };
                shape.userData.spin = { x: 0, y: 0, z: 0.5 };
                shape.material.opacity = 1;
                shape.scale.setScalar(0.8);
            }
        }

        function triggerBounce(el) {
            const center = getElementCenter(el);

            for (let i = 0; i < 3; i++) {
                const shape = shapes.find(s => !s.userData.active);
                if (shape) {
                    shape.position.copy(center);
                    shape.position.z = 0;
                    shape.userData.active = true;
                    shape.userData.life = 1.5;
                    shape.userData.velocity = {
                        x: (Math.random() - 0.5) * 0.05,
                        y: 0.1 + Math.random() * 0.05,
                        z: 0
                    };
                    shape.userData.spin = {
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    };
                    shape.userData.gravity = true;
                    shape.material.opacity = 1;
                    shape.scale.setScalar(0.4);
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // EVENT LISTENERS
        // ═══════════════════════════════════════════════════════════════

        const effectMap = {
            'explode': triggerExplode,
            'wave': triggerWave,
            'vortex': triggerVortex,
            'glitch': triggerGlitch,
            'ripple': triggerRipple,
            'wobble': triggerWobble,
            'spin': triggerSpin,
            'bounce': triggerBounce
        };

        document.querySelectorAll('.chaos-target').forEach(el => {
            el.addEventListener('mouseenter', () => {
                const effect = el.dataset.effect;
                if (effectMap[effect]) {
                    effectMap[effect](el);
                }
            });
        });

        // ═══════════════════════════════════════════════════════════════
        // ANIMATION LOOP
        // ═══════════════════════════════════════════════════════════════

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update particles
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                if (particleLifetimes[i] > 0) {
                    positions[i * 3] += particleVelocities[i].x;
                    positions[i * 3 + 1] += particleVelocities[i].y;
                    positions[i * 3 + 2] += particleVelocities[i].z;

                    particleVelocities[i].y -= 0.002; // Gravity
                    particleLifetimes[i] -= delta;

                    if (particleLifetimes[i] <= 0) {
                        positions[i * 3 + 2] = -100;
                    }
                }
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Update shapes
            shapes.forEach(shape => {
                if (shape.userData.active) {
                    if (shape.userData.orbit) {
                        shape.userData.orbit.angle += shape.userData.orbit.speed;
                        shape.position.x = shape.userData.orbit.center.x + Math.cos(shape.userData.orbit.angle) * shape.userData.orbit.radius;
                        shape.position.y = shape.userData.orbit.center.y + Math.sin(shape.userData.orbit.angle) * shape.userData.orbit.radius * 0.6;
                    } else {
                        shape.position.x += shape.userData.velocity.x;
                        shape.position.y += shape.userData.velocity.y;
                        shape.position.z += shape.userData.velocity.z;

                        if (shape.userData.gravity) {
                            shape.userData.velocity.y -= 0.005;
                        }
                    }

                    shape.rotation.x += shape.userData.spin.x;
                    shape.rotation.y += shape.userData.spin.y;
                    shape.rotation.z += shape.userData.spin.z;

                    shape.userData.life -= delta;
                    shape.material.opacity = Math.max(0, shape.userData.life);

                    if (shape.userData.life <= 0) {
                        shape.userData.active = false;
                        shape.userData.orbit = null;
                        shape.userData.gravity = false;
                        shape.position.z = -100;
                    }
                }
            });

            // Update wave lines
            waveLines.forEach((line, i) => {
                if (line.userData.active) {
                    const positions = line.geometry.attributes.position.array;
                    for (let j = 0; j < 50; j++) {
                        positions[j * 3 + 1] = Math.sin(time * 10 + j * 0.3 + line.userData.offset) * line.userData.amplitude;
                    }
                    line.geometry.attributes.position.needsUpdate = true;

                    line.userData.amplitude *= 0.95;
                    line.material.opacity *= 0.98;

                    if (line.userData.amplitude < 0.01) {
                        line.userData.active = false;
                        line.position.z = -100;
                    }
                }
            });

            // Update vortex rings
            vortexRings.forEach(ring => {
                if (ring.userData.active) {
                    ring.scale.lerp(new THREE.Vector3(ring.userData.targetScale, ring.userData.targetScale, ring.userData.targetScale), 0.1);
                    ring.rotation.z += ring.userData.spin;
                    ring.material.opacity *= 0.97;

                    if (ring.material.opacity < 0.05) {
                        ring.userData.active = false;
                        ring.position.z = -100;
                    }
                }
            });

            // Screen shake
            if (shakeIntensity > 0.001) {
                camera.position.x = (Math.random() - 0.5) * shakeIntensity;
                camera.position.y = (Math.random() - 0.5) * shakeIntensity;
                shakeIntensity *= shakeDecay;
            } else {
                camera.position.x = 0;
                camera.position.y = 0;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
